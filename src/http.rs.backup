use axum::{
    extract::State,
    http::StatusCode,
    middleware,
    response::IntoResponse,
    routing::post,
    Json as AxumJson, Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::{
    auth::{bearer_auth_middleware, AuthConfig},
    error::{McpError, McpResult},
    runtime::{McpProcess, McpRequest, McpResponse},
};

/// HTTP request/response structures
#[derive(Serialize, Deserialize, Debug)]
pub struct HttpRequest {
    pub command: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct HttpResponse {
    pub result: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
}

/// Convert HTTP request to MCP request
impl From<HttpRequest> for McpRequest {
    fn from(req: HttpRequest) -> Self {
        Self {
            command: req.command,
        }
    }
}

/// Convert MCP response to HTTP response
impl From<McpResponse> for HttpResponse {
    fn from(resp: McpResponse) -> Self {
        Self {
            result: resp.result,
        }
    }
}

/// Main HTTP request handler
pub async fn handle_mcp_request(
    State(mcp_process_mutex): State<Arc<Mutex<McpProcess>>>,
    AxumJson(payload): AxumJson<HttpRequest>,
) -> Result<AxumJson<HttpResponse>, impl IntoResponse> {
    tracing::debug!(request = ?payload, "Received HTTP request");

    let mut mcp_process_guard = mcp_process_mutex.lock().await;
    tracing::trace!("Acquired MCP process mutex lock");

    let mcp_request = payload.into();
    match mcp_process_guard.query(&mcp_request).await {
        Ok(response) => {
            tracing::debug!(response = ?response, "MCP query successful");
            Ok(AxumJson(response.into()))
        }
        Err(e) => {
            tracing::error!(error = %e, "MCP query failed");
            
            let (status, error_msg) = match e {
                McpError::Timeout(_) => (StatusCode::REQUEST_TIMEOUT, e.to_string()),
                McpError::Process(_) => (StatusCode::BAD_GATEWAY, e.to_string()),
                McpError::Auth(_) => (StatusCode::UNAUTHORIZED, e.to_string()),
                _ => (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string()),
            };
            
            let error_response = ErrorResponse {
                error: "MCP Error".to_string(),
                message: error_msg,
            };
            
            Err((status, AxumJson(error_response)))
        }
    }
}

/// Health check handler
pub async fn health_check() -> impl IntoResponse {
    AxumJson(serde_json::json!({
        "status": "healthy",
        "service": "mcp-http-server-core"
    }))
}

/// Create the Axum router with middleware
pub fn create_router(
    mcp_process: Arc<Mutex<McpProcess>>,
    auth_config: AuthConfig,
) -> Router {
    Router::new()
        .route("/api/v1", post(handle_mcp_request))
        .route("/health", axum::routing::get(health_check))
        .layer(middleware::from_fn(move |headers, request, next| {
            let auth_config = auth_config.clone();
            bearer_auth_middleware(auth_config, headers, request, next)
        }))
        .with_state(mcp_process)
}
